; Copyright (C) 2024 Robin Sergeant
;
; banked bios

OUTC		EQU 1
MSG		EQU 23
CHAN		EQU 24
KBDTL		EQU 31
KBDW		EQU 33
WIDTH		EQU 52
RDSECL		EQU 68
WRSECL		EQU 69
FLUSH		EQU 71
RDINFO		EQU 72

CCP_LEN		EQU 25
CCP_SIZE	EQU CCP_LEN * 128
PORT1_MASK	EQU 0FF01H
PORT0		EQU 018H
PORT1		EQU 019H

		EXTERNAL @mxtpa

		CSEG

		ORG 0

		JP boot		; initial entry on cold start
wboot_entry:	JP wboot	; reentry on program exit, warm start

		JP const	; return console input status
		JP conin	; return console input character
		JP conout	; send console output character
		JP list		; send list output character
		JP auxout	; send auxilliary output character
		JP auxin	; return auxilliary input character

		JP home		; set disks to logical home
		JP seldsk	; select disk drive, return disk parameter info
		JP settrk	; set disk track
		JP setsec	; set disk sector
		JP setdma	; set disk I/O memory address
		JP read		; read physical block(s)
		JP write	; write physical block(s)

		JP listst	; return list device status
		JP sectrn	; translate logical to physical sector

		JP conost	; return console output status
		JP auxist	; return aux input status
		JP auxost	; return aux output status
		JP devtbl	; return address of device def table
		JP cinit	; change baud rate of device

		JP getdrv	; return address of disk drive table
		JP multio	; set multiple record count for disk I/O
		JP flushdsk	; flush BIOS maintained disk caching

		JP move		; block move memory to memory
		JP time		; Signal Time and Date operation
		JP bnksel	; select bank for code execution and default DMA
		JP setbnk	; select different bank for disk I/O DMA operations.
		JP xmove	; set source and destination banks for one operation

		JP 0		; reserved for future expansion
		JP 0		; reserved for future expansion
		JP 0		; reserved for future expansion

		DSEG

boot:		LD SP,bios_stack
		CALL init_page0

		DI
		LD B,2		; map RAM bank 4 to 8000H
		LD C,PORT0
		LD A,4
		OUT (C),A

		PUSH BC
		LD DE,8000H	; move first 16K of system block
		LD HL,0000H
		LD BC,4000H
		LDIR
		POP BC

		INC A		; map RAM bank 5 to 8000H
		OUT (C),A

		PUSH BC
		LD DE,8000H	; move second 16K of system block
		LD BC,4000H
		LDIR
		POP BC

		LD A,3		; map RAM bank 3 back to 8000H
		OUT (C),A
		EI

		LD HL,sign_on
		EMT MSG

		LD IX,unit		; load CCP from track 2
		LD HL,(address)
		LD BC,128

read_loop:	EMT RDSECL
		JR NZ,read_error

		ADD HL,BC		; advance buffer
		LD (address),HL
		LD A,(sector)		; increment sector no.
		INC A
		LD (sector),A
		CP CCP_LEN+1
		JR C,read_loop

		LD C,PORT1		; select Page 3 (all RAM)
		LD A,(PORT1_MASK)
		OR 3
		DI			; disable interrupts while
		OUT (C),A		; ROM is unavailable

		LD DE,0E800H		; copy CCP to hidden area
		LD HL,0100H		; of RAM (behind ROM) so
		LD BC,CCP_SIZE		; we can quickly copy it back
		LDIR			; during a warm boot

		LD C,PORT1		; return to Page 1
		LD A,(PORT1_MASK)
		OUT (C),A
		EI			; re-enable interrupts

		JP 0100H		; start CCP

read_error:	LD HL,ccp_err_msg
		EMT MSG
		HALT			; nothing more we can do

		CSEG

wboot:		LD SP,bios_stack
		LD A,1			; make sure we are in bank 1
		CALL switch_bnk
		CALL init_page0

		LD A,1			; set 80 column mode in case changed
		EMT WIDTH

		LD C,PORT1		; select Page 3 (all RAM)
		LD A,(PORT1_MASK)
		OR 3
		DI			; disable interrupts while
		OUT (C),A		; ROM is unavailable

		LD DE,0100H		; copy CCP back to TPA
		LD HL,0E800H
		LD BC,CCP_SIZE
		LDIR

		LD C,PORT1		; return to Page 1
		LD A,(PORT1_MASK)
		OUT (C),A
		EI			; re-enable interrupts

		JP 0100H		; start CCP

init_page0:	LD A,0C3H
		LD HL,wboot_entry
		LD (0000H),A
		LD (0001H),HL

		LD HL,(@mxtpa)
		LD (0005H),A
		LD (0006H),HL

		RET

const:		LD (saved_sp),SP
		LD SP,bios_stack
		PUSH BC
		LD C,KBDTL
		CALL safe_emt
		POP BC
		LD SP,(saved_sp)
		RET

conin:		LD (saved_sp),SP
		LD SP,bios_stack
		PUSH BC
		LD C,KBDW
		CALL safe_emt
		POP BC
		LD SP,(saved_sp)
		RET

conout:		LD (saved_sp),SP
		LD SP,bios_stack
		PUSH BC
		PUSH AF
		LD A,C
		LD C,OUTC
		CALL safe_emt
		POP AF
		POP BC
		LD SP,(saved_sp)
		RET

conost:		LD A,0FFH
		RET

		DSEG

home:		LD IX,unit
		LD (IX+1),0
		RET

seldsk:		LD (saved_sp),SP
		LD SP,bios_stack
		PUSH AF
		PUSH BC
		LD B,0			; find DPH
		SLA C
		LD IY,drive_table
		ADD IY,BC		
		LD H,(IY+1)
		LD L,(IY+0)
		PUSH HL
		POP IY			; IY now contains address of DPH
		SRL C
		LD HL,drive_info
		ADD HL,BC		; HL contains location for stored unit byte
		BIT 0,E
		JR Z,read_info		; Read disc info when bit 0 unset
		POP BC
		LD A,(HL)		; else reuse data previously found for drive
		JR set_unit
read_info:	LD IX,unit
		LD (IX+0),C
		LD C,RDINFO
		CALL safe_emt
		POP BC
		JR Z,rdinfo_ok
		LD IY,0			; return null DPH on error
		JR seldsk_ret
rdinfo_ok:	AND 00000110B		; keep data and track density
		SLA A			; shift to bits 5 and 6 to
		SLA A			; form drive unit byte
		SLA A
		SLA A
		OR C			; add drive number to unit
		LD (HL),A		; store in drive info table
		LD HL,dpb_sd
		BIT 5,A
		JR Z,set_dpd		; use SD when bit 5 clear
		LD HL,dpb_dd
		BIT 6,A
		JR Z,set_dpd		; use DD when bit 6 clear
		LD HL,dpb_qd		; else use QD
set_dpd:	LD (IY+12),L
		LD (IY+13),H
set_unit:	LD (unit),A
seldsk_ret:	POP AF
		PUSH IY			; transfer DPH to HL
		POP HL
		LD SP,(saved_sp)
		RET

settrk:		LD IX,unit
		LD (IX+1),C
		RET

setsec:		LD IX,unit
		LD (IX+2),C
		RET

setdma:		LD (address),BC
		LD (buffer_addr),BC
		RET

setbnk:		LD (dma_bank),A
		RET

sectrn:		LD HL,unit
		BIT 5,(HL)
		JR Z,translate		; translate for SD only
		LD H,B
		LD L,C
		INC L			; otherwise just adjust to start from 1
		RET
translate:	LD HL,xlt
		ADD HL,BC
		LD L,(HL)
		LD H,B			; B will always be zero as < 255 sectors
		RET

getdrv:		LD HL,drive_table
		RET

read:		LD (saved_sp),SP
		LD SP,bios_stack
		PUSH BC
		LD IX,unit
		LD C,RDSECL
		LD A,(dma_bank)
		CP 1
		JR Z,read_no_cpy	; can read directly into dest
		PUSH HL
		LD HL,common_buffer	; otherwise use common buffer
		LD (address),HL
		CALL safe_emt
		JR NZ,read_skip		; skip buffer copy on failure
		PUSH DE
		PUSH AF
		LD DE,(buffer_addr)
		LD BC,128
		LDIR			; copy buffer to dest
		POP AF
		POP DE
read_skip:	POP HL
		JR read_done
read_no_cpy:	CALL safe_emt
read_done:	LD A,1			; return 1 if an error occured
		JR NZ,read_ret		
		XOR A			; return 0 on sucess
read_ret:	POP BC
		LD SP,(saved_sp)
		RET

flushdsk:	LD (saved_sp),SP
		LD SP,bios_stack
		PUSH BC
		LD IX,flush_unit
		LD C,FLUSH
		CALL safe_emt
		JR check_write

write:		LD (saved_sp),SP
		LD SP,bios_stack
		PUSH BC
		LD A,(dma_bank)
		CP 1
		JR Z,do_write		; no need to copy buffer
		PUSH DE
		PUSH HL
		LD DE,common_buffer
		LD HL,(address)
		LD BC,128
		LD (address),de
		LDIR			; copy buffer to common area
		POP HL
		POP DE
do_write:	LD C,WRSECL
		LD IX,unit
		CALL safe_emt
check_write:	JR Z,write_ok
		BIT 6,A
		LD A,1			; return 1 for general failure
		JR Z,write_ret		; (write protect bit not set)
		JR C,write_ret		; (IDC protocol error)
		INC A
		JR write_ret		; return 2 if disc write protected
write_ok:	XOR A
write_ret:	POP BC
		LD SP,(saved_sp)
		RET			; return 0 on sucess

		CSEG

move:		EX DE,HL
		LDIR
		EX DE,HL
		RET

bnksel:		LD (current_bank),A
switch_bnk:	CP 1
		JR Z,sel_bank1
sel_bank0:	LD A,4			; bank 0 maps to blocks 4 and 5
		DI			; disable interrupts while in bank 0
		EXX			; preserve BC
		LD BC,PORT0
		OUT (C),A
		INC B			; increment B to map region 0x4000H to 0x8000H
		INC A			; increment A to select block 5
		OUT (C),A
		EXX			; restore BC
		RET
sel_bank1:	LD A,1			; bank 1 maps to blocks 1 and 2
		EXX
		LD BC,PORT0
		OUT (C),A
		INC B			; increment B to map region 0x4000H to 0x8000H
		INC A			; increment A to select block 2
		OUT (C),A
		EXX
		EI			; enable interrupts again in bank 1

not_supported:
list:
auxout:
auxin:
listst:
auxist:
auxost:
devtbl:
cinit:
multio:
time:
xmove:		RET

safe_emt:	PUSH AF
		PUSH HL
		LD HL,current_bank
		LD A,1
		CP (HL)
		POP HL
		JR Z,quick_emt
		CALL switch_bnk
		POP AF
		EMT CHAN
		PUSH AF
		LD A,0
		CALL switch_bnk
		POP AF
		RET

quick_emt:	POP AF
		EMT CHAN
		RET

drive_table:	DEFW dph0,dph1,dph2,dph3
		DEFW 0,0,0,0,0,0,0,0,0,0,0,0

dph0:		DEFW 0			; XLT
		DEFB 0,0,0,0,0,0,0,0,0	; scratch area
		DEFB 0			; MF
		DEFW dpb_qd		; DPB
		DEFW 0FFFEH		; CSV (generated by GENCPM)
		DEFW 0FFFEH		; ALV (generated by GENCPM)
		DEFW 0FFFEH		; DIRBCB (generated by GENCPM)
		DEFW 0FFFFH		; DTABCB (not used)
		DEFW 0FFFEH		; HASH (generated by GENCPM)
		DEFW 0			; HBANK (not used)

dph1:		DEFW 0			; XLT
		DEFB 0,0,0,0,0,0,0,0,0	; scratch area
		DEFB 0			; MF
		DEFW dpb_qd		; DPB
		DEFW 0FFFEH		; CSV (generated by GENCPM)
		DEFW 0FFFEH		; ALV (generated by GENCPM)
		DEFW 0FFFEH		; DIRBCB (generated by GENCPM)
		DEFW 0FFFFH		; DTABCB (not used)
		DEFW 0FFFEH		; HASH (generated by GENCPM)
		DEFW 0			; HBANK (not used)

dph2:		DEFW 0			; XLT
		DEFB 0,0,0,0,0,0,0,0,0	; scratch area
		DEFB 0			; MF
		DEFW dpb_qd		; DPB
		DEFW 0FFFEH		; CSV (generated by GENCPM)
		DEFW 0FFFEH		; ALV (generated by GENCPM)
		DEFW 0FFFEH		; DIRBCB (generated by GENCPM)
		DEFW 0FFFFH		; DTABCB (not used)
		DEFW 0FFFEH		; HASH (generated by GENCPM)
		DEFW 0			; HBANK (not used)

dph3:		DEFW 0			; XLT
		DEFB 0,0,0,0,0,0,0,0,0	; scratch area
		DEFB 0			; MF
		DEFW dpb_qd		; DPB
		DEFW 0FFFEH		; CSV (generated by GENCPM)
		DEFW 0FFFEH		; ALV (generated by GENCPM)
		DEFW 0FFFEH		; DIRBCB (generated by GENCPM)
		DEFW 0FFFFH		; DTABCB (not used)
		DEFW 0FFFEH		; HASH (generated by GENCPM)
		DEFW 0			; HBANK (not used)

dpb_dd:		DEFW 36		; SPT
		DEFB 3		; BSH
		DEFB 7		; BLM
		DEFB 0		; EXM
		DEFW 165	; DSM
		DEFW 63		; DRM
		DEFB 0C0H	; AL0
		DEFB 0		; AL1
		DEFW 16		; CKS
		DEFW 3		; OFF
		DEFB 0		; PSH
		DEFB 0		; PHM

dpb_qd:		DEFW 36		; SPT
		DEFB 4		; BSH
		DEFB 15		; BLM
		DEFB 1		; EXM
		DEFW 172	; DSM
		DEFW 127	; DRM
		DEFB 0C0H	; AL0
		DEFB 0		; AL1
		DEFW 32		; CKS
		DEFW 3		; OFF
		DEFB 0		; PSH
		DEFB 0		; PHM

dpb_sd:		DEFW 16		; SPT
		DEFB 3		; BSH
		DEFB 7		; BLM
		DEFB 0		; EXM
		DEFW 73		; DSM
		DEFW 63		; DRM
		DEFB 0C0H	; AL0
		DEFB 0		; AL1
		DEFW 16		; CKS
		DEFW 3		; OFF
		DEFB 0		; PSH
		DEFB 0		; PHM

unit:		DEFB 00100000B
track:		DEFB 2
sector:		DEFB 1
address:	DEFW 0100H

flush_unit:	DEFB 00001000B

current_bank:	DEFB 1
dma_bank:	DEFS 1

buffer_addr:	DEFS 2
common_buffer:	DEFS 128

saved_sp:	DEFS 2

		DEFS 64
bios_stack:

		DSEG

sign_on:	DEFB 31
		DEFM 'CP/M Plus (3.0) for RM 480Z'
		DEFB 13,13
		DEFM 'BIOS v 0.2 Copyright (C) 2024, Robin Sergeant'
		DEFB 13,13,-1

ccp_err_msg:	DEFM 'ERROR unable to load CCP from disc'
		DEFB -1

xlt:		DEFB 1,4,7,10,13,16,3,6,9,12,15,2,5,8,11,14

drive_info:	DEFS 4
